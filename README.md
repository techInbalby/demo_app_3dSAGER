# 3dSAGER Demo Application

A web-based interactive demo application for visualizing and analyzing results from the 3dSAGER pipeline. This application provides a user-friendly interface for exploring pre-computed inference results, visualizing 3D building models, and comparing matching predictions.

## Overview

The 3dSAGER (3D Spatial Attribute-based Geospatial Entity Resolution) system is designed to match and resolve entities between two different 3D city model datasets. This demo application **displays pre-computed inference results** from the 3dSAGER pipeline, including:

- **3D Visualization**: Interactive 3D viewer using CesiumJS for geospatial building visualization (no base map in main viewer)
- **BKAFI Blocking Results**: Visualization of candidate pairs generated by the BKAFI (Blocking Key Attribute Feature Importance) algorithm
- **Matching Classifier Results**: Display of predictions from the XGBoost-based matching classifier with confidence scores
- **Performance Metrics**: Comprehensive evaluation metrics including precision, recall, and F1 scores
- **Interactive Comparison**: Visual comparison of candidate and index buildings with confidence scores

**Note**: This application does **not** run the BKAFI blocking or matching classifier models. It loads and visualizes pre-computed results from JSON files generated by the 3dSAGER inference pipeline.

## Features

### Core Functionality

1. **File Management**
   - Load CityJSON files from Source A (candidates) and Source B (index)
   - Support for multiple file formats and coordinate reference systems
   - Automatic file detection and path resolution

2. **3D Visualization**
   - Interactive CesiumJS-based 3D viewer (no base map)
   - Clickable buildings with detailed information
   - Color-coded building status (matched, unmatched, true positive, false positive)
   - Building comparison viewer for candidate-index pairs
   - Location map in sidebar (Leaflet) showing The Hague location

3. **BKAFI Blocking Results**
   - Load and visualize pre-computed candidate pairs from BKAFI algorithm
   - Display blocking results for each building
   - Filter and explore potential matches
   - View side-by-side comparison of candidate-index pairs

4. **Matching Classifier Results**
   - Display pre-computed XGBoost matching predictions
   - Show confidence scores for each candidate pair
   - Visualize threshold-based and best-match strategies
   - View detailed performance metrics

5. **Performance Analysis**
   - Overall metrics (precision, recall, F1 score)
   - Blocking recall and matching recall
   - False positive and false negative analysis
   - Per-file performance breakdown

## Installation

### Prerequisites

- Python 3.8 or higher
- Docker and Docker Compose (optional, for containerized deployment)
- Node.js (for frontend dependencies, if needed)

### Local Installation

1. **Clone the repository** (if applicable) or navigate to the project directory

2. **Create a virtual environment** (recommended):
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. **Install Python dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

4. **Set up directories**:
   The application will automatically create necessary directories:
   - `data/` - Input CityJSON files
   - `results_demo/` - Inference results and metrics
   - `saved_model_files/` - Trained model files
   - `logs/` - Application logs

5. **Prepare data files**:
   - Place CityJSON files in `data/RawCitiesData/The Hague/Source A/` (candidates)
   - Place CityJSON files in `data/RawCitiesData/The Hague/Source B/` (index)
   - Place geometric features file in `data/property_dicts/`:
     - `Hague_demo_130425_demo_inference_vector_normalization=True_seed=1.joblib` (or your corresponding property file)
   - Ensure results JSON files are in `results_demo/demo_inference/`:
     - `demo_detailed_results_XGBClassifier_seed1.json`
     - `demo_metrics_summary_seed1.json`
     - `demo_matches_XGBClassifier_seed1.json`

### Docker Installation

1. **Build and run with Docker Compose**:
   ```bash
   docker-compose up --build
   ```

2. **Access the application**:
   - Open your browser to `http://localhost:5001`

3. **Stop the application**:
   ```bash
   docker-compose down
   ```

## Usage

### Starting the Application

**Local development:**
```bash
python app.py
```

The application will be available at `http://localhost:5000`

**Docker:**
```bash
docker-compose up
```

The application will be available at `http://localhost:5001`

### Using the Application

1. **Load Files**
   - Select a file from Source A (candidates) or Source B (index)
   - The 3D viewer will automatically load and display the buildings

2. **Explore Buildings**
   - Click on any building in the 3D viewer to see its details
   - View geometric features and properties
   - Check BKAFI blocking pairs

3. **Load BKAFI Results** (Step 2)
   - Click "Load BKAFI Results" to load pre-computed blocking results from JSON file
   - View candidate pairs for each building (pre-computed by the BKAFI algorithm)
   - Click "View Pairs Visually" to see side-by-side comparison

4. **View Matching Results** (Step 3)
   - Matching results are automatically loaded with BKAFI results (from pre-computed inference)
   - Buildings are color-coded based on match status:
     - **Blue**: Default/unmatched
     - **Orange**: Has geometric features
     - **Yellow**: Has BKAFI pairs
     - **Green**: True match
     - **Red**: False positive
     - **Gray**: No match

5. **View Summary Metrics**
   - Click "Show Summary" in Step 3 to see detailed performance metrics
   - Metrics include:
     - Overall recall, blocking recall, matching recall
     - Precision (threshold-based and best match)
     - F1 score
     - True positives, false positives, false negatives

## Project Structure

```
demo_app_3dSAGER/
├── app.py                          # Main Flask application
├── requirements.txt                # Python dependencies
├── Dockerfile                      # Docker image configuration
├── docker-compose.yml              # Docker Compose configuration
├── README.md                       # This file
│
├── data/                           # Input data directory
│   ├── RawCitiesData/
│   │   └── The Hague/
│   │       ├── Source A/          # Candidate buildings
│   │       └── Source B/          # Index buildings
│   └── property_dicts/            # Geometric features
│
├── results_demo/                   # Results and metrics
│   └── demo_inference/
│       ├── demo_detailed_results_XGBClassifier_seed1.json
│       ├── demo_matches_XGBClassifier_seed1.json
│       └── demo_metrics_summary_seed1.json
│
├── saved_model_files/              # Trained model files
│   └── saved_model_files_partition_by_file/
│
├── static/                         # Static web assets
│   ├── css/                        # Stylesheets
│   ├── js/                         # JavaScript files
│   │   ├── cesium-cityjson-viewer.js  # Cesium 3D viewer
│   │   ├── demo.js                 # Main application logic
│   │   └── three-building-viewer.js   # Three.js comparison viewer
│   └── images/                     # Image assets
│
├── templates/                      # HTML templates
│   ├── index.html                  # Home page
│   └── demo.html                   # Demo page
│
└── logs/                           # Application logs
```

## API Endpoints

### File Management

- `GET /api/data/files` - Get list of available CityJSON files
- `GET /api/data/file/<path:file_path>` - Get CityJSON file content
- `POST /api/data/select` - Select a file for processing

### Building Operations

- `GET /api/building/single/<building_id>?file=<file_path>` - Get single building as minimal CityJSON
- `GET /api/building/find-file/<building_id>` - Find which file contains a building
- `GET /api/building/features/<building_id>?file=<file_path>` - Get geometric features for a building
- `GET /api/building/bkafi/<building_id>?file=<file_path>` - Get BKAFI pairs for a building
- `GET /api/building/matches/<building_id>?file=<file_path>` - Get matching results for a building

### BKAFI Blocking Results

- `POST /api/bkafi/load` - Load pre-computed BKAFI blocking results from JSON file

### Matching and Metrics

- `GET /api/classifier/summary?file=<file_path>` - Get classifier performance summary
- `GET /api/buildings/status?file=<file_path>` - Get match status for all buildings in a file

## Configuration

### Data Paths

The application looks for data in the following locations (in order of priority):

**Source A (Candidates):**
- `data/RawCitiesData/The Hague/Source A/`
- `data/RawCitiesData/The Hague/SourceA/`

**Source B (Index):**
- `data/RawCitiesData/The Hague/Source B/`
- `data/RawCitiesData/The Hague/SourceB/`

### Results Files

The application expects the following results files in `results_demo/demo_inference/`:

- `demo_detailed_results_XGBClassifier_seed1.json` - Detailed matching results
- `demo_metrics_summary_seed1.json` - Performance metrics summary
- `demo_matches_XGBClassifier_seed1.json` - Match predictions

### Coordinate Reference Systems

The application supports CityJSON files in various coordinate reference systems:

- **EPSG:7415** (compound CRS) - Automatically transformed to WGS84
- **EPSG:28992** (RD New) - Automatically transformed to WGS84
- **EPSG:4326** (WGS84) - Used directly

The Cesium viewer automatically handles coordinate transformations using proj4js.

**Note**: The Cesium viewer does not display a base map. Buildings are displayed on a plain background. A small location map (Leaflet) is available in the sidebar showing The Hague location.

### Confidence Threshold

The default confidence threshold for predictions is **0.5**. This can be modified in `app.py`:

```python
CONFIDENCE_THRESHOLD = 0.5
```

## Important Notes

### Pre-computed Results

This application **does not run** the BKAFI blocking or matching classifier models. It is designed to visualize and explore **pre-computed inference results** from the 3dSAGER pipeline.

To generate the results files:
1. Run the 3dSAGER inference pipeline on your CityJSON datasets
2. The pipeline will generate:
   - `demo_detailed_results_XGBClassifier_seed1.json` - Detailed matching results
   - `demo_metrics_summary_seed1.json` - Performance metrics
   - `demo_matches_XGBClassifier_seed1.json` - Match predictions
3. Place these files in `results_demo/demo_inference/`
4. The demo application will load and visualize these results

## Data Format

### CityJSON Files

The application expects CityJSON format files (version 1.0 or 1.1) with:

- `CityObjects` - Dictionary of building objects
- `vertices` - Array of vertex coordinates
- `metadata` - File metadata including CRS information
- `transform` (optional) - Coordinate transformation parameters

### Results JSON Format

**Detailed Results** (`demo_detailed_results_XGBClassifier_seed1.json`):
```json
{
  "filename.json": {
    "building_id": {
      "possible_matches": [
        {
          "index_id": "index_building_id",
          "confidence": 0.85,
          "true_label": 1,
          "predicted_label": 1
        }
      ]
    }
  }
}
```

**Metrics Summary** (`demo_metrics_summary_seed1.json`):
```json
{
  "XGBClassifier": {
    "file_metrics": {
      "filename.json": {
        "potential_matches_in_index": 100,
        "threshold_precision": 0.85,
        "threshold_recall_overall": 0.75,
        "best_match_precision": 0.90,
        ...
      }
    }
  }
}
```

## Troubleshooting

### Common Issues

1. **Buildings not appearing in 3D viewer**
   - Check browser console for errors
   - Verify CityJSON file format is valid
   - Ensure coordinate system is supported
   - Check that Cesium library loaded correctly

2. **File not found errors**
   - Verify file paths in `data/RawCitiesData/`
   - Check file naming conventions (spaces vs. no spaces)
   - Ensure files have `.json` extension

3. **BKAFI results not loading**
   - Verify `results_demo/demo_inference/demo_detailed_results_XGBClassifier_seed1.json` exists
   - This file should contain pre-computed inference results from the 3dSAGER pipeline
   - Check JSON file format is valid
   - Review application logs for errors
   - **Note**: The app does not generate these results - they must be pre-computed by running the 3dSAGER inference pipeline

4. **Docker container issues**
   - Rebuild container: `docker-compose up --build`
   - Check container logs: `docker-compose logs`
   - Verify volume mounts are correct

### Performance Optimization

- **Large files**: The application uses compression for API responses
- **Caching**: File lookups are optimized for repeated searches
- **Lazy loading**: Buildings are loaded on-demand in comparison viewer

## Development

### Running in Development Mode

```bash
export FLASK_ENV=development
export FLASK_DEBUG=1
python app.py
```

### Adding New Features

1. **Backend**: Add routes in `app.py`
2. **Frontend**: Update `static/js/demo.js` for UI logic
3. **3D Viewer**: Modify `static/js/cesium-cityjson-viewer.js` for visualization
4. **Styles**: Update `static/css/demo.css` for styling

### Testing

Run tests (if available):
```bash
python -m pytest tests/
```

## Dependencies

### Python Packages

- Flask 3.0.0 - Web framework
- pandas 2.1.4 - Data processing (for reading results)
- numpy 1.24.3 - Numerical computing
- joblib 1.3.2 - Loading geometric features from joblib files

**Note**: XGBoost and scikit-learn are listed in requirements.txt but are **not used** in this demo application. This app only visualizes pre-computed results. The 3dSAGER pipeline uses these libraries for training and inference.

### Frontend Libraries (via CDN)

- CesiumJS (v1.110) - 3D globe visualization (main viewer), uses WebGL for rendering
- Three.js (r128) - 3D building comparison viewer, uses WebGL for rendering
- Leaflet (v1.9.4) - Location map in sidebar
- proj4js (v2.9.0) - Coordinate transformation

**Note**: Both CesiumJS and Three.js utilize WebGL (Web Graphics Library) for hardware-accelerated 3D rendering in the browser. WebGL is a web standard supported by all modern browsers.

See `requirements.txt` for complete Python package list.

## License

This project is licensed under the Apache License 2.0. See the `3dSAGER_LICENSE` file for details.

### Third-Party Licenses

This application uses several third-party libraries, each with their own licenses:

- **Backend (Python)**: Flask (BSD), NumPy (BSD), SciPy (BSD), XGBoost (Apache 2.0), scikit-learn (BSD), pandas (BSD), requests (Apache 2.0), and others - all permissive licenses compatible with Apache 2.0
- **Frontend (JavaScript)**: CesiumJS (Apache 2.0), Three.js (MIT), Leaflet (BSD), proj4js (MIT) - all permissive licenses compatible with Apache 2.0

All licenses are compatible with Apache License 2.0. See the `NOTICE` file for complete attribution and license information for all third-party components.

## About 3dSAGER

This demo application visualizes results from the **3dSAGER** (3D Spatial Attribute-based Geospatial Entity Resolution) pipeline.

### 3dSAGER Project Information

- **Repository**: https://github.com/BarGenossar/3dSAGER
- **Paper**: https://arxiv.org/pdf/2511.06300
- **Authors**: Bar Genossar, Sagi Dalyot, Roee Shraga, Avigdor Gal
- **License**: Apache License 2.0 (see `3dSAGER_LICENSE` file)
- **Description**: 3dSAGER is a research project for matching and resolving entities between different 3D city model datasets using coordinate-agnostic geometric features and machine learning.

### 3dSAGER Pipeline Components

The 3dSAGER pipeline includes:
- **Geometric Feature Extraction**: Coordinate-agnostic featurization of 3D building meshes
- **BKAFI Blocking**: Blocking Key Attribute Feature Importance algorithm for candidate pair generation
- **Matching Classifier**: XGBoost-based classifier for predicting building matches
- **Evaluation Metrics**: Comprehensive performance evaluation including precision, recall, and F1 scores

**Note**: This demo application only visualizes pre-computed results from the 3dSAGER pipeline. To run the full pipeline and generate new results, please refer to the 3dSAGER repository.

## Citation

If you use this application or the 3dSAGER pipeline in your research, please cite:

**3dSAGER: Geospatial Entity Resolution over 3D Objects.** In Proceedings of [Conference Name] (Conference acronym 'XX). ACM, New York, NY, USA, 16 pages.

*Note: Please update with the complete citation including authors, full conference name, and year from the published paper.*

## Contact

[Add contact information here]

For questions about:
- **This demo application**: [Add demo app contact]
- **3dSAGER pipeline**: [Add 3dSAGER project contact or GitHub issues]

## Acknowledgments

- CesiumJS for 3D globe visualization
- CityJSON community for the data format specification

## Development Note

This demo application was developed with the assistance of AI tools for code generation and implementation. The application structure, API endpoints, frontend components, and documentation were created with AI assistance to accelerate development.
